// Code generated by counterfeiter. DO NOT EDIT.
package networkfakes

import (
	"context"
	"sync"

	"github.com/ehsaniara/joblet/internal/joblet/network"
)

type FakeMonitor struct {
	GetBandwidthStatsStub        func(string) (*network.BandwidthStats, error)
	getBandwidthStatsMutex       sync.RWMutex
	getBandwidthStatsArgsForCall []struct {
		arg1 string
	}
	getBandwidthStatsReturns struct {
		result1 *network.BandwidthStats
		result2 error
	}
	getBandwidthStatsReturnsOnCall map[int]struct {
		result1 *network.BandwidthStats
		result2 error
	}
	GetNetworkStatsStub        func(string) (*network.BandwidthStats, error)
	getNetworkStatsMutex       sync.RWMutex
	getNetworkStatsArgsForCall []struct {
		arg1 string
	}
	getNetworkStatsReturns struct {
		result1 *network.BandwidthStats
		result2 error
	}
	getNetworkStatsReturnsOnCall map[int]struct {
		result1 *network.BandwidthStats
		result2 error
	}
	SetBandwidthLimitsStub        func(string, *network.NetworkLimits) error
	setBandwidthLimitsMutex       sync.RWMutex
	setBandwidthLimitsArgsForCall []struct {
		arg1 string
		arg2 *network.NetworkLimits
	}
	setBandwidthLimitsReturns struct {
		result1 error
	}
	setBandwidthLimitsReturnsOnCall map[int]struct {
		result1 error
	}
	StartMonitoringStub        func(context.Context) error
	startMonitoringMutex       sync.RWMutex
	startMonitoringArgsForCall []struct {
		arg1 context.Context
	}
	startMonitoringReturns struct {
		result1 error
	}
	startMonitoringReturnsOnCall map[int]struct {
		result1 error
	}
	StopMonitoringStub        func() error
	stopMonitoringMutex       sync.RWMutex
	stopMonitoringArgsForCall []struct {
	}
	stopMonitoringReturns struct {
		result1 error
	}
	stopMonitoringReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMonitor) GetBandwidthStats(arg1 string) (*network.BandwidthStats, error) {
	fake.getBandwidthStatsMutex.Lock()
	ret, specificReturn := fake.getBandwidthStatsReturnsOnCall[len(fake.getBandwidthStatsArgsForCall)]
	fake.getBandwidthStatsArgsForCall = append(fake.getBandwidthStatsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBandwidthStatsStub
	fakeReturns := fake.getBandwidthStatsReturns
	fake.recordInvocation("GetBandwidthStats", []interface{}{arg1})
	fake.getBandwidthStatsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMonitor) GetBandwidthStatsCallCount() int {
	fake.getBandwidthStatsMutex.RLock()
	defer fake.getBandwidthStatsMutex.RUnlock()
	return len(fake.getBandwidthStatsArgsForCall)
}

func (fake *FakeMonitor) GetBandwidthStatsCalls(stub func(string) (*network.BandwidthStats, error)) {
	fake.getBandwidthStatsMutex.Lock()
	defer fake.getBandwidthStatsMutex.Unlock()
	fake.GetBandwidthStatsStub = stub
}

func (fake *FakeMonitor) GetBandwidthStatsArgsForCall(i int) string {
	fake.getBandwidthStatsMutex.RLock()
	defer fake.getBandwidthStatsMutex.RUnlock()
	argsForCall := fake.getBandwidthStatsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMonitor) GetBandwidthStatsReturns(result1 *network.BandwidthStats, result2 error) {
	fake.getBandwidthStatsMutex.Lock()
	defer fake.getBandwidthStatsMutex.Unlock()
	fake.GetBandwidthStatsStub = nil
	fake.getBandwidthStatsReturns = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeMonitor) GetBandwidthStatsReturnsOnCall(i int, result1 *network.BandwidthStats, result2 error) {
	fake.getBandwidthStatsMutex.Lock()
	defer fake.getBandwidthStatsMutex.Unlock()
	fake.GetBandwidthStatsStub = nil
	if fake.getBandwidthStatsReturnsOnCall == nil {
		fake.getBandwidthStatsReturnsOnCall = make(map[int]struct {
			result1 *network.BandwidthStats
			result2 error
		})
	}
	fake.getBandwidthStatsReturnsOnCall[i] = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeMonitor) GetNetworkStats(arg1 string) (*network.BandwidthStats, error) {
	fake.getNetworkStatsMutex.Lock()
	ret, specificReturn := fake.getNetworkStatsReturnsOnCall[len(fake.getNetworkStatsArgsForCall)]
	fake.getNetworkStatsArgsForCall = append(fake.getNetworkStatsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetNetworkStatsStub
	fakeReturns := fake.getNetworkStatsReturns
	fake.recordInvocation("GetNetworkStats", []interface{}{arg1})
	fake.getNetworkStatsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMonitor) GetNetworkStatsCallCount() int {
	fake.getNetworkStatsMutex.RLock()
	defer fake.getNetworkStatsMutex.RUnlock()
	return len(fake.getNetworkStatsArgsForCall)
}

func (fake *FakeMonitor) GetNetworkStatsCalls(stub func(string) (*network.BandwidthStats, error)) {
	fake.getNetworkStatsMutex.Lock()
	defer fake.getNetworkStatsMutex.Unlock()
	fake.GetNetworkStatsStub = stub
}

func (fake *FakeMonitor) GetNetworkStatsArgsForCall(i int) string {
	fake.getNetworkStatsMutex.RLock()
	defer fake.getNetworkStatsMutex.RUnlock()
	argsForCall := fake.getNetworkStatsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMonitor) GetNetworkStatsReturns(result1 *network.BandwidthStats, result2 error) {
	fake.getNetworkStatsMutex.Lock()
	defer fake.getNetworkStatsMutex.Unlock()
	fake.GetNetworkStatsStub = nil
	fake.getNetworkStatsReturns = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeMonitor) GetNetworkStatsReturnsOnCall(i int, result1 *network.BandwidthStats, result2 error) {
	fake.getNetworkStatsMutex.Lock()
	defer fake.getNetworkStatsMutex.Unlock()
	fake.GetNetworkStatsStub = nil
	if fake.getNetworkStatsReturnsOnCall == nil {
		fake.getNetworkStatsReturnsOnCall = make(map[int]struct {
			result1 *network.BandwidthStats
			result2 error
		})
	}
	fake.getNetworkStatsReturnsOnCall[i] = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeMonitor) SetBandwidthLimits(arg1 string, arg2 *network.NetworkLimits) error {
	fake.setBandwidthLimitsMutex.Lock()
	ret, specificReturn := fake.setBandwidthLimitsReturnsOnCall[len(fake.setBandwidthLimitsArgsForCall)]
	fake.setBandwidthLimitsArgsForCall = append(fake.setBandwidthLimitsArgsForCall, struct {
		arg1 string
		arg2 *network.NetworkLimits
	}{arg1, arg2})
	stub := fake.SetBandwidthLimitsStub
	fakeReturns := fake.setBandwidthLimitsReturns
	fake.recordInvocation("SetBandwidthLimits", []interface{}{arg1, arg2})
	fake.setBandwidthLimitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMonitor) SetBandwidthLimitsCallCount() int {
	fake.setBandwidthLimitsMutex.RLock()
	defer fake.setBandwidthLimitsMutex.RUnlock()
	return len(fake.setBandwidthLimitsArgsForCall)
}

func (fake *FakeMonitor) SetBandwidthLimitsCalls(stub func(string, *network.NetworkLimits) error) {
	fake.setBandwidthLimitsMutex.Lock()
	defer fake.setBandwidthLimitsMutex.Unlock()
	fake.SetBandwidthLimitsStub = stub
}

func (fake *FakeMonitor) SetBandwidthLimitsArgsForCall(i int) (string, *network.NetworkLimits) {
	fake.setBandwidthLimitsMutex.RLock()
	defer fake.setBandwidthLimitsMutex.RUnlock()
	argsForCall := fake.setBandwidthLimitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMonitor) SetBandwidthLimitsReturns(result1 error) {
	fake.setBandwidthLimitsMutex.Lock()
	defer fake.setBandwidthLimitsMutex.Unlock()
	fake.SetBandwidthLimitsStub = nil
	fake.setBandwidthLimitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) SetBandwidthLimitsReturnsOnCall(i int, result1 error) {
	fake.setBandwidthLimitsMutex.Lock()
	defer fake.setBandwidthLimitsMutex.Unlock()
	fake.SetBandwidthLimitsStub = nil
	if fake.setBandwidthLimitsReturnsOnCall == nil {
		fake.setBandwidthLimitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBandwidthLimitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) StartMonitoring(arg1 context.Context) error {
	fake.startMonitoringMutex.Lock()
	ret, specificReturn := fake.startMonitoringReturnsOnCall[len(fake.startMonitoringArgsForCall)]
	fake.startMonitoringArgsForCall = append(fake.startMonitoringArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StartMonitoringStub
	fakeReturns := fake.startMonitoringReturns
	fake.recordInvocation("StartMonitoring", []interface{}{arg1})
	fake.startMonitoringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMonitor) StartMonitoringCallCount() int {
	fake.startMonitoringMutex.RLock()
	defer fake.startMonitoringMutex.RUnlock()
	return len(fake.startMonitoringArgsForCall)
}

func (fake *FakeMonitor) StartMonitoringCalls(stub func(context.Context) error) {
	fake.startMonitoringMutex.Lock()
	defer fake.startMonitoringMutex.Unlock()
	fake.StartMonitoringStub = stub
}

func (fake *FakeMonitor) StartMonitoringArgsForCall(i int) context.Context {
	fake.startMonitoringMutex.RLock()
	defer fake.startMonitoringMutex.RUnlock()
	argsForCall := fake.startMonitoringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMonitor) StartMonitoringReturns(result1 error) {
	fake.startMonitoringMutex.Lock()
	defer fake.startMonitoringMutex.Unlock()
	fake.StartMonitoringStub = nil
	fake.startMonitoringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) StartMonitoringReturnsOnCall(i int, result1 error) {
	fake.startMonitoringMutex.Lock()
	defer fake.startMonitoringMutex.Unlock()
	fake.StartMonitoringStub = nil
	if fake.startMonitoringReturnsOnCall == nil {
		fake.startMonitoringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startMonitoringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) StopMonitoring() error {
	fake.stopMonitoringMutex.Lock()
	ret, specificReturn := fake.stopMonitoringReturnsOnCall[len(fake.stopMonitoringArgsForCall)]
	fake.stopMonitoringArgsForCall = append(fake.stopMonitoringArgsForCall, struct {
	}{})
	stub := fake.StopMonitoringStub
	fakeReturns := fake.stopMonitoringReturns
	fake.recordInvocation("StopMonitoring", []interface{}{})
	fake.stopMonitoringMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMonitor) StopMonitoringCallCount() int {
	fake.stopMonitoringMutex.RLock()
	defer fake.stopMonitoringMutex.RUnlock()
	return len(fake.stopMonitoringArgsForCall)
}

func (fake *FakeMonitor) StopMonitoringCalls(stub func() error) {
	fake.stopMonitoringMutex.Lock()
	defer fake.stopMonitoringMutex.Unlock()
	fake.StopMonitoringStub = stub
}

func (fake *FakeMonitor) StopMonitoringReturns(result1 error) {
	fake.stopMonitoringMutex.Lock()
	defer fake.stopMonitoringMutex.Unlock()
	fake.StopMonitoringStub = nil
	fake.stopMonitoringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) StopMonitoringReturnsOnCall(i int, result1 error) {
	fake.stopMonitoringMutex.Lock()
	defer fake.stopMonitoringMutex.Unlock()
	fake.StopMonitoringStub = nil
	if fake.stopMonitoringReturnsOnCall == nil {
		fake.stopMonitoringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopMonitoringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMonitor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ network.Monitor = new(FakeMonitor)
