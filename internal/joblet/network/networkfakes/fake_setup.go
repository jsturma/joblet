// Code generated by counterfeiter. DO NOT EDIT.
package networkfakes

import (
	"joblet/internal/joblet/network"
	"sync"
)

type FakeSetup struct {
	AttachVethToBridgeStub        func(string, string) error
	attachVethToBridgeMutex       sync.RWMutex
	attachVethToBridgeArgsForCall []struct {
		arg1 string
		arg2 string
	}
	attachVethToBridgeReturns struct {
		result1 error
	}
	attachVethToBridgeReturnsOnCall map[int]struct {
		result1 error
	}
	BridgeExistsStub        func(string) bool
	bridgeExistsMutex       sync.RWMutex
	bridgeExistsArgsForCall []struct {
		arg1 string
	}
	bridgeExistsReturns struct {
		result1 bool
	}
	bridgeExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	CleanupNamespaceStub        func(string) error
	cleanupNamespaceMutex       sync.RWMutex
	cleanupNamespaceArgsForCall []struct {
		arg1 string
	}
	cleanupNamespaceReturns struct {
		result1 error
	}
	cleanupNamespaceReturnsOnCall map[int]struct {
		result1 error
	}
	CreateBridgeStub        func(string, string) error
	createBridgeMutex       sync.RWMutex
	createBridgeArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createBridgeReturns struct {
		result1 error
	}
	createBridgeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateVethPairStub        func(string, string) error
	createVethPairMutex       sync.RWMutex
	createVethPairArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createVethPairReturns struct {
		result1 error
	}
	createVethPairReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteBridgeStub        func(string) error
	deleteBridgeMutex       sync.RWMutex
	deleteBridgeArgsForCall []struct {
		arg1 string
	}
	deleteBridgeReturns struct {
		result1 error
	}
	deleteBridgeReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVethPairStub        func(string, string) error
	deleteVethPairMutex       sync.RWMutex
	deleteVethPairArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteVethPairReturns struct {
		result1 error
	}
	deleteVethPairReturnsOnCall map[int]struct {
		result1 error
	}
	SetupNamespaceStub        func(string, *network.JobAllocation) error
	setupNamespaceMutex       sync.RWMutex
	setupNamespaceArgsForCall []struct {
		arg1 string
		arg2 *network.JobAllocation
	}
	setupNamespaceReturns struct {
		result1 error
	}
	setupNamespaceReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSetup) AttachVethToBridge(arg1 string, arg2 string) error {
	fake.attachVethToBridgeMutex.Lock()
	ret, specificReturn := fake.attachVethToBridgeReturnsOnCall[len(fake.attachVethToBridgeArgsForCall)]
	fake.attachVethToBridgeArgsForCall = append(fake.attachVethToBridgeArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AttachVethToBridgeStub
	fakeReturns := fake.attachVethToBridgeReturns
	fake.recordInvocation("AttachVethToBridge", []interface{}{arg1, arg2})
	fake.attachVethToBridgeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) AttachVethToBridgeCallCount() int {
	fake.attachVethToBridgeMutex.RLock()
	defer fake.attachVethToBridgeMutex.RUnlock()
	return len(fake.attachVethToBridgeArgsForCall)
}

func (fake *FakeSetup) AttachVethToBridgeCalls(stub func(string, string) error) {
	fake.attachVethToBridgeMutex.Lock()
	defer fake.attachVethToBridgeMutex.Unlock()
	fake.AttachVethToBridgeStub = stub
}

func (fake *FakeSetup) AttachVethToBridgeArgsForCall(i int) (string, string) {
	fake.attachVethToBridgeMutex.RLock()
	defer fake.attachVethToBridgeMutex.RUnlock()
	argsForCall := fake.attachVethToBridgeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSetup) AttachVethToBridgeReturns(result1 error) {
	fake.attachVethToBridgeMutex.Lock()
	defer fake.attachVethToBridgeMutex.Unlock()
	fake.AttachVethToBridgeStub = nil
	fake.attachVethToBridgeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) AttachVethToBridgeReturnsOnCall(i int, result1 error) {
	fake.attachVethToBridgeMutex.Lock()
	defer fake.attachVethToBridgeMutex.Unlock()
	fake.AttachVethToBridgeStub = nil
	if fake.attachVethToBridgeReturnsOnCall == nil {
		fake.attachVethToBridgeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachVethToBridgeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) BridgeExists(arg1 string) bool {
	fake.bridgeExistsMutex.Lock()
	ret, specificReturn := fake.bridgeExistsReturnsOnCall[len(fake.bridgeExistsArgsForCall)]
	fake.bridgeExistsArgsForCall = append(fake.bridgeExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BridgeExistsStub
	fakeReturns := fake.bridgeExistsReturns
	fake.recordInvocation("BridgeExists", []interface{}{arg1})
	fake.bridgeExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) BridgeExistsCallCount() int {
	fake.bridgeExistsMutex.RLock()
	defer fake.bridgeExistsMutex.RUnlock()
	return len(fake.bridgeExistsArgsForCall)
}

func (fake *FakeSetup) BridgeExistsCalls(stub func(string) bool) {
	fake.bridgeExistsMutex.Lock()
	defer fake.bridgeExistsMutex.Unlock()
	fake.BridgeExistsStub = stub
}

func (fake *FakeSetup) BridgeExistsArgsForCall(i int) string {
	fake.bridgeExistsMutex.RLock()
	defer fake.bridgeExistsMutex.RUnlock()
	argsForCall := fake.bridgeExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSetup) BridgeExistsReturns(result1 bool) {
	fake.bridgeExistsMutex.Lock()
	defer fake.bridgeExistsMutex.Unlock()
	fake.BridgeExistsStub = nil
	fake.bridgeExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSetup) BridgeExistsReturnsOnCall(i int, result1 bool) {
	fake.bridgeExistsMutex.Lock()
	defer fake.bridgeExistsMutex.Unlock()
	fake.BridgeExistsStub = nil
	if fake.bridgeExistsReturnsOnCall == nil {
		fake.bridgeExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.bridgeExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSetup) CleanupNamespace(arg1 string) error {
	fake.cleanupNamespaceMutex.Lock()
	ret, specificReturn := fake.cleanupNamespaceReturnsOnCall[len(fake.cleanupNamespaceArgsForCall)]
	fake.cleanupNamespaceArgsForCall = append(fake.cleanupNamespaceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CleanupNamespaceStub
	fakeReturns := fake.cleanupNamespaceReturns
	fake.recordInvocation("CleanupNamespace", []interface{}{arg1})
	fake.cleanupNamespaceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) CleanupNamespaceCallCount() int {
	fake.cleanupNamespaceMutex.RLock()
	defer fake.cleanupNamespaceMutex.RUnlock()
	return len(fake.cleanupNamespaceArgsForCall)
}

func (fake *FakeSetup) CleanupNamespaceCalls(stub func(string) error) {
	fake.cleanupNamespaceMutex.Lock()
	defer fake.cleanupNamespaceMutex.Unlock()
	fake.CleanupNamespaceStub = stub
}

func (fake *FakeSetup) CleanupNamespaceArgsForCall(i int) string {
	fake.cleanupNamespaceMutex.RLock()
	defer fake.cleanupNamespaceMutex.RUnlock()
	argsForCall := fake.cleanupNamespaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSetup) CleanupNamespaceReturns(result1 error) {
	fake.cleanupNamespaceMutex.Lock()
	defer fake.cleanupNamespaceMutex.Unlock()
	fake.CleanupNamespaceStub = nil
	fake.cleanupNamespaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) CleanupNamespaceReturnsOnCall(i int, result1 error) {
	fake.cleanupNamespaceMutex.Lock()
	defer fake.cleanupNamespaceMutex.Unlock()
	fake.CleanupNamespaceStub = nil
	if fake.cleanupNamespaceReturnsOnCall == nil {
		fake.cleanupNamespaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupNamespaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) CreateBridge(arg1 string, arg2 string) error {
	fake.createBridgeMutex.Lock()
	ret, specificReturn := fake.createBridgeReturnsOnCall[len(fake.createBridgeArgsForCall)]
	fake.createBridgeArgsForCall = append(fake.createBridgeArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateBridgeStub
	fakeReturns := fake.createBridgeReturns
	fake.recordInvocation("CreateBridge", []interface{}{arg1, arg2})
	fake.createBridgeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) CreateBridgeCallCount() int {
	fake.createBridgeMutex.RLock()
	defer fake.createBridgeMutex.RUnlock()
	return len(fake.createBridgeArgsForCall)
}

func (fake *FakeSetup) CreateBridgeCalls(stub func(string, string) error) {
	fake.createBridgeMutex.Lock()
	defer fake.createBridgeMutex.Unlock()
	fake.CreateBridgeStub = stub
}

func (fake *FakeSetup) CreateBridgeArgsForCall(i int) (string, string) {
	fake.createBridgeMutex.RLock()
	defer fake.createBridgeMutex.RUnlock()
	argsForCall := fake.createBridgeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSetup) CreateBridgeReturns(result1 error) {
	fake.createBridgeMutex.Lock()
	defer fake.createBridgeMutex.Unlock()
	fake.CreateBridgeStub = nil
	fake.createBridgeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) CreateBridgeReturnsOnCall(i int, result1 error) {
	fake.createBridgeMutex.Lock()
	defer fake.createBridgeMutex.Unlock()
	fake.CreateBridgeStub = nil
	if fake.createBridgeReturnsOnCall == nil {
		fake.createBridgeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createBridgeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) CreateVethPair(arg1 string, arg2 string) error {
	fake.createVethPairMutex.Lock()
	ret, specificReturn := fake.createVethPairReturnsOnCall[len(fake.createVethPairArgsForCall)]
	fake.createVethPairArgsForCall = append(fake.createVethPairArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateVethPairStub
	fakeReturns := fake.createVethPairReturns
	fake.recordInvocation("CreateVethPair", []interface{}{arg1, arg2})
	fake.createVethPairMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) CreateVethPairCallCount() int {
	fake.createVethPairMutex.RLock()
	defer fake.createVethPairMutex.RUnlock()
	return len(fake.createVethPairArgsForCall)
}

func (fake *FakeSetup) CreateVethPairCalls(stub func(string, string) error) {
	fake.createVethPairMutex.Lock()
	defer fake.createVethPairMutex.Unlock()
	fake.CreateVethPairStub = stub
}

func (fake *FakeSetup) CreateVethPairArgsForCall(i int) (string, string) {
	fake.createVethPairMutex.RLock()
	defer fake.createVethPairMutex.RUnlock()
	argsForCall := fake.createVethPairArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSetup) CreateVethPairReturns(result1 error) {
	fake.createVethPairMutex.Lock()
	defer fake.createVethPairMutex.Unlock()
	fake.CreateVethPairStub = nil
	fake.createVethPairReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) CreateVethPairReturnsOnCall(i int, result1 error) {
	fake.createVethPairMutex.Lock()
	defer fake.createVethPairMutex.Unlock()
	fake.CreateVethPairStub = nil
	if fake.createVethPairReturnsOnCall == nil {
		fake.createVethPairReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createVethPairReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) DeleteBridge(arg1 string) error {
	fake.deleteBridgeMutex.Lock()
	ret, specificReturn := fake.deleteBridgeReturnsOnCall[len(fake.deleteBridgeArgsForCall)]
	fake.deleteBridgeArgsForCall = append(fake.deleteBridgeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteBridgeStub
	fakeReturns := fake.deleteBridgeReturns
	fake.recordInvocation("DeleteBridge", []interface{}{arg1})
	fake.deleteBridgeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) DeleteBridgeCallCount() int {
	fake.deleteBridgeMutex.RLock()
	defer fake.deleteBridgeMutex.RUnlock()
	return len(fake.deleteBridgeArgsForCall)
}

func (fake *FakeSetup) DeleteBridgeCalls(stub func(string) error) {
	fake.deleteBridgeMutex.Lock()
	defer fake.deleteBridgeMutex.Unlock()
	fake.DeleteBridgeStub = stub
}

func (fake *FakeSetup) DeleteBridgeArgsForCall(i int) string {
	fake.deleteBridgeMutex.RLock()
	defer fake.deleteBridgeMutex.RUnlock()
	argsForCall := fake.deleteBridgeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSetup) DeleteBridgeReturns(result1 error) {
	fake.deleteBridgeMutex.Lock()
	defer fake.deleteBridgeMutex.Unlock()
	fake.DeleteBridgeStub = nil
	fake.deleteBridgeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) DeleteBridgeReturnsOnCall(i int, result1 error) {
	fake.deleteBridgeMutex.Lock()
	defer fake.deleteBridgeMutex.Unlock()
	fake.DeleteBridgeStub = nil
	if fake.deleteBridgeReturnsOnCall == nil {
		fake.deleteBridgeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBridgeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) DeleteVethPair(arg1 string, arg2 string) error {
	fake.deleteVethPairMutex.Lock()
	ret, specificReturn := fake.deleteVethPairReturnsOnCall[len(fake.deleteVethPairArgsForCall)]
	fake.deleteVethPairArgsForCall = append(fake.deleteVethPairArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteVethPairStub
	fakeReturns := fake.deleteVethPairReturns
	fake.recordInvocation("DeleteVethPair", []interface{}{arg1, arg2})
	fake.deleteVethPairMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) DeleteVethPairCallCount() int {
	fake.deleteVethPairMutex.RLock()
	defer fake.deleteVethPairMutex.RUnlock()
	return len(fake.deleteVethPairArgsForCall)
}

func (fake *FakeSetup) DeleteVethPairCalls(stub func(string, string) error) {
	fake.deleteVethPairMutex.Lock()
	defer fake.deleteVethPairMutex.Unlock()
	fake.DeleteVethPairStub = stub
}

func (fake *FakeSetup) DeleteVethPairArgsForCall(i int) (string, string) {
	fake.deleteVethPairMutex.RLock()
	defer fake.deleteVethPairMutex.RUnlock()
	argsForCall := fake.deleteVethPairArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSetup) DeleteVethPairReturns(result1 error) {
	fake.deleteVethPairMutex.Lock()
	defer fake.deleteVethPairMutex.Unlock()
	fake.DeleteVethPairStub = nil
	fake.deleteVethPairReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) DeleteVethPairReturnsOnCall(i int, result1 error) {
	fake.deleteVethPairMutex.Lock()
	defer fake.deleteVethPairMutex.Unlock()
	fake.DeleteVethPairStub = nil
	if fake.deleteVethPairReturnsOnCall == nil {
		fake.deleteVethPairReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVethPairReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) SetupNamespace(arg1 string, arg2 *network.JobAllocation) error {
	fake.setupNamespaceMutex.Lock()
	ret, specificReturn := fake.setupNamespaceReturnsOnCall[len(fake.setupNamespaceArgsForCall)]
	fake.setupNamespaceArgsForCall = append(fake.setupNamespaceArgsForCall, struct {
		arg1 string
		arg2 *network.JobAllocation
	}{arg1, arg2})
	stub := fake.SetupNamespaceStub
	fakeReturns := fake.setupNamespaceReturns
	fake.recordInvocation("SetupNamespace", []interface{}{arg1, arg2})
	fake.setupNamespaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSetup) SetupNamespaceCallCount() int {
	fake.setupNamespaceMutex.RLock()
	defer fake.setupNamespaceMutex.RUnlock()
	return len(fake.setupNamespaceArgsForCall)
}

func (fake *FakeSetup) SetupNamespaceCalls(stub func(string, *network.JobAllocation) error) {
	fake.setupNamespaceMutex.Lock()
	defer fake.setupNamespaceMutex.Unlock()
	fake.SetupNamespaceStub = stub
}

func (fake *FakeSetup) SetupNamespaceArgsForCall(i int) (string, *network.JobAllocation) {
	fake.setupNamespaceMutex.RLock()
	defer fake.setupNamespaceMutex.RUnlock()
	argsForCall := fake.setupNamespaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSetup) SetupNamespaceReturns(result1 error) {
	fake.setupNamespaceMutex.Lock()
	defer fake.setupNamespaceMutex.Unlock()
	fake.SetupNamespaceStub = nil
	fake.setupNamespaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) SetupNamespaceReturnsOnCall(i int, result1 error) {
	fake.setupNamespaceMutex.Lock()
	defer fake.setupNamespaceMutex.Unlock()
	fake.SetupNamespaceStub = nil
	if fake.setupNamespaceReturnsOnCall == nil {
		fake.setupNamespaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupNamespaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSetup) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSetup) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ network.Setup = new(FakeSetup)
