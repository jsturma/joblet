// Code generated by counterfeiter. DO NOT EDIT.
package networkfakes

import (
	"context"
	"sync"

	"github.com/ehsaniara/joblet/internal/joblet/network"
)

type FakeManager struct {
	AllocateIPStub        func(string, string) (*network.JobAllocation, error)
	allocateIPMutex       sync.RWMutex
	allocateIPArgsForCall []struct {
		arg1 string
		arg2 string
	}
	allocateIPReturns struct {
		result1 *network.JobAllocation
		result2 error
	}
	allocateIPReturnsOnCall map[int]struct {
		result1 *network.JobAllocation
		result2 error
	}
	CleanupJobNetworkingStub        func(string) error
	cleanupJobNetworkingMutex       sync.RWMutex
	cleanupJobNetworkingArgsForCall []struct {
		arg1 string
	}
	cleanupJobNetworkingReturns struct {
		result1 error
	}
	cleanupJobNetworkingReturnsOnCall map[int]struct {
		result1 error
	}
	CreateNetworkStub        func(string, *network.NetworkConfig) error
	createNetworkMutex       sync.RWMutex
	createNetworkArgsForCall []struct {
		arg1 string
		arg2 *network.NetworkConfig
	}
	createNetworkReturns struct {
		result1 error
	}
	createNetworkReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyNetworkStub        func(string) error
	destroyNetworkMutex       sync.RWMutex
	destroyNetworkArgsForCall []struct {
		arg1 string
	}
	destroyNetworkReturns struct {
		result1 error
	}
	destroyNetworkReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllocationStub        func(string) (*network.JobAllocation, error)
	getAllocationMutex       sync.RWMutex
	getAllocationArgsForCall []struct {
		arg1 string
	}
	getAllocationReturns struct {
		result1 *network.JobAllocation
		result2 error
	}
	getAllocationReturnsOnCall map[int]struct {
		result1 *network.JobAllocation
		result2 error
	}
	GetBandwidthStatsStub        func(string) (*network.BandwidthStats, error)
	getBandwidthStatsMutex       sync.RWMutex
	getBandwidthStatsArgsForCall []struct {
		arg1 string
	}
	getBandwidthStatsReturns struct {
		result1 *network.BandwidthStats
		result2 error
	}
	getBandwidthStatsReturnsOnCall map[int]struct {
		result1 *network.BandwidthStats
		result2 error
	}
	GetNetworkInfoStub        func(string) (*network.NetworkInfo, error)
	getNetworkInfoMutex       sync.RWMutex
	getNetworkInfoArgsForCall []struct {
		arg1 string
	}
	getNetworkInfoReturns struct {
		result1 *network.NetworkInfo
		result2 error
	}
	getNetworkInfoReturnsOnCall map[int]struct {
		result1 *network.NetworkInfo
		result2 error
	}
	GetNetworkStatsStub        func(string) (*network.BandwidthStats, error)
	getNetworkStatsMutex       sync.RWMutex
	getNetworkStatsArgsForCall []struct {
		arg1 string
	}
	getNetworkStatsReturns struct {
		result1 *network.BandwidthStats
		result2 error
	}
	getNetworkStatsReturnsOnCall map[int]struct {
		result1 *network.BandwidthStats
		result2 error
	}
	ListAllocationsStub        func(string) ([]network.JobAllocation, error)
	listAllocationsMutex       sync.RWMutex
	listAllocationsArgsForCall []struct {
		arg1 string
	}
	listAllocationsReturns struct {
		result1 []network.JobAllocation
		result2 error
	}
	listAllocationsReturnsOnCall map[int]struct {
		result1 []network.JobAllocation
		result2 error
	}
	ListNetworksStub        func() ([]network.NetworkInfo, error)
	listNetworksMutex       sync.RWMutex
	listNetworksArgsForCall []struct {
	}
	listNetworksReturns struct {
		result1 []network.NetworkInfo
		result2 error
	}
	listNetworksReturnsOnCall map[int]struct {
		result1 []network.NetworkInfo
		result2 error
	}
	NetworkExistsStub        func(string) bool
	networkExistsMutex       sync.RWMutex
	networkExistsArgsForCall []struct {
		arg1 string
	}
	networkExistsReturns struct {
		result1 bool
	}
	networkExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	ReleaseIPStub        func(string) error
	releaseIPMutex       sync.RWMutex
	releaseIPArgsForCall []struct {
		arg1 string
	}
	releaseIPReturns struct {
		result1 error
	}
	releaseIPReturnsOnCall map[int]struct {
		result1 error
	}
	SetBandwidthLimitsStub        func(string, *network.NetworkLimits) error
	setBandwidthLimitsMutex       sync.RWMutex
	setBandwidthLimitsArgsForCall []struct {
		arg1 string
		arg2 *network.NetworkLimits
	}
	setBandwidthLimitsReturns struct {
		result1 error
	}
	setBandwidthLimitsReturnsOnCall map[int]struct {
		result1 error
	}
	SetupJobNetworkingStub        func(string, string) (*network.JobAllocation, error)
	setupJobNetworkingMutex       sync.RWMutex
	setupJobNetworkingArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setupJobNetworkingReturns struct {
		result1 *network.JobAllocation
		result2 error
	}
	setupJobNetworkingReturnsOnCall map[int]struct {
		result1 *network.JobAllocation
		result2 error
	}
	StartMonitoringStub        func(context.Context) error
	startMonitoringMutex       sync.RWMutex
	startMonitoringArgsForCall []struct {
		arg1 context.Context
	}
	startMonitoringReturns struct {
		result1 error
	}
	startMonitoringReturnsOnCall map[int]struct {
		result1 error
	}
	StopMonitoringStub        func() error
	stopMonitoringMutex       sync.RWMutex
	stopMonitoringArgsForCall []struct {
	}
	stopMonitoringReturns struct {
		result1 error
	}
	stopMonitoringReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateNetworkConfigStub        func(*network.NetworkConfig) error
	validateNetworkConfigMutex       sync.RWMutex
	validateNetworkConfigArgsForCall []struct {
		arg1 *network.NetworkConfig
	}
	validateNetworkConfigReturns struct {
		result1 error
	}
	validateNetworkConfigReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) AllocateIP(arg1 string, arg2 string) (*network.JobAllocation, error) {
	fake.allocateIPMutex.Lock()
	ret, specificReturn := fake.allocateIPReturnsOnCall[len(fake.allocateIPArgsForCall)]
	fake.allocateIPArgsForCall = append(fake.allocateIPArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AllocateIPStub
	fakeReturns := fake.allocateIPReturns
	fake.recordInvocation("AllocateIP", []interface{}{arg1, arg2})
	fake.allocateIPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) AllocateIPCallCount() int {
	fake.allocateIPMutex.RLock()
	defer fake.allocateIPMutex.RUnlock()
	return len(fake.allocateIPArgsForCall)
}

func (fake *FakeManager) AllocateIPCalls(stub func(string, string) (*network.JobAllocation, error)) {
	fake.allocateIPMutex.Lock()
	defer fake.allocateIPMutex.Unlock()
	fake.AllocateIPStub = stub
}

func (fake *FakeManager) AllocateIPArgsForCall(i int) (string, string) {
	fake.allocateIPMutex.RLock()
	defer fake.allocateIPMutex.RUnlock()
	argsForCall := fake.allocateIPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) AllocateIPReturns(result1 *network.JobAllocation, result2 error) {
	fake.allocateIPMutex.Lock()
	defer fake.allocateIPMutex.Unlock()
	fake.AllocateIPStub = nil
	fake.allocateIPReturns = struct {
		result1 *network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) AllocateIPReturnsOnCall(i int, result1 *network.JobAllocation, result2 error) {
	fake.allocateIPMutex.Lock()
	defer fake.allocateIPMutex.Unlock()
	fake.AllocateIPStub = nil
	if fake.allocateIPReturnsOnCall == nil {
		fake.allocateIPReturnsOnCall = make(map[int]struct {
			result1 *network.JobAllocation
			result2 error
		})
	}
	fake.allocateIPReturnsOnCall[i] = struct {
		result1 *network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CleanupJobNetworking(arg1 string) error {
	fake.cleanupJobNetworkingMutex.Lock()
	ret, specificReturn := fake.cleanupJobNetworkingReturnsOnCall[len(fake.cleanupJobNetworkingArgsForCall)]
	fake.cleanupJobNetworkingArgsForCall = append(fake.cleanupJobNetworkingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CleanupJobNetworkingStub
	fakeReturns := fake.cleanupJobNetworkingReturns
	fake.recordInvocation("CleanupJobNetworking", []interface{}{arg1})
	fake.cleanupJobNetworkingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) CleanupJobNetworkingCallCount() int {
	fake.cleanupJobNetworkingMutex.RLock()
	defer fake.cleanupJobNetworkingMutex.RUnlock()
	return len(fake.cleanupJobNetworkingArgsForCall)
}

func (fake *FakeManager) CleanupJobNetworkingCalls(stub func(string) error) {
	fake.cleanupJobNetworkingMutex.Lock()
	defer fake.cleanupJobNetworkingMutex.Unlock()
	fake.CleanupJobNetworkingStub = stub
}

func (fake *FakeManager) CleanupJobNetworkingArgsForCall(i int) string {
	fake.cleanupJobNetworkingMutex.RLock()
	defer fake.cleanupJobNetworkingMutex.RUnlock()
	argsForCall := fake.cleanupJobNetworkingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) CleanupJobNetworkingReturns(result1 error) {
	fake.cleanupJobNetworkingMutex.Lock()
	defer fake.cleanupJobNetworkingMutex.Unlock()
	fake.CleanupJobNetworkingStub = nil
	fake.cleanupJobNetworkingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) CleanupJobNetworkingReturnsOnCall(i int, result1 error) {
	fake.cleanupJobNetworkingMutex.Lock()
	defer fake.cleanupJobNetworkingMutex.Unlock()
	fake.CleanupJobNetworkingStub = nil
	if fake.cleanupJobNetworkingReturnsOnCall == nil {
		fake.cleanupJobNetworkingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupJobNetworkingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) CreateNetwork(arg1 string, arg2 *network.NetworkConfig) error {
	fake.createNetworkMutex.Lock()
	ret, specificReturn := fake.createNetworkReturnsOnCall[len(fake.createNetworkArgsForCall)]
	fake.createNetworkArgsForCall = append(fake.createNetworkArgsForCall, struct {
		arg1 string
		arg2 *network.NetworkConfig
	}{arg1, arg2})
	stub := fake.CreateNetworkStub
	fakeReturns := fake.createNetworkReturns
	fake.recordInvocation("CreateNetwork", []interface{}{arg1, arg2})
	fake.createNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) CreateNetworkCallCount() int {
	fake.createNetworkMutex.RLock()
	defer fake.createNetworkMutex.RUnlock()
	return len(fake.createNetworkArgsForCall)
}

func (fake *FakeManager) CreateNetworkCalls(stub func(string, *network.NetworkConfig) error) {
	fake.createNetworkMutex.Lock()
	defer fake.createNetworkMutex.Unlock()
	fake.CreateNetworkStub = stub
}

func (fake *FakeManager) CreateNetworkArgsForCall(i int) (string, *network.NetworkConfig) {
	fake.createNetworkMutex.RLock()
	defer fake.createNetworkMutex.RUnlock()
	argsForCall := fake.createNetworkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) CreateNetworkReturns(result1 error) {
	fake.createNetworkMutex.Lock()
	defer fake.createNetworkMutex.Unlock()
	fake.CreateNetworkStub = nil
	fake.createNetworkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) CreateNetworkReturnsOnCall(i int, result1 error) {
	fake.createNetworkMutex.Lock()
	defer fake.createNetworkMutex.Unlock()
	fake.CreateNetworkStub = nil
	if fake.createNetworkReturnsOnCall == nil {
		fake.createNetworkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createNetworkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DestroyNetwork(arg1 string) error {
	fake.destroyNetworkMutex.Lock()
	ret, specificReturn := fake.destroyNetworkReturnsOnCall[len(fake.destroyNetworkArgsForCall)]
	fake.destroyNetworkArgsForCall = append(fake.destroyNetworkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DestroyNetworkStub
	fakeReturns := fake.destroyNetworkReturns
	fake.recordInvocation("DestroyNetwork", []interface{}{arg1})
	fake.destroyNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) DestroyNetworkCallCount() int {
	fake.destroyNetworkMutex.RLock()
	defer fake.destroyNetworkMutex.RUnlock()
	return len(fake.destroyNetworkArgsForCall)
}

func (fake *FakeManager) DestroyNetworkCalls(stub func(string) error) {
	fake.destroyNetworkMutex.Lock()
	defer fake.destroyNetworkMutex.Unlock()
	fake.DestroyNetworkStub = stub
}

func (fake *FakeManager) DestroyNetworkArgsForCall(i int) string {
	fake.destroyNetworkMutex.RLock()
	defer fake.destroyNetworkMutex.RUnlock()
	argsForCall := fake.destroyNetworkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) DestroyNetworkReturns(result1 error) {
	fake.destroyNetworkMutex.Lock()
	defer fake.destroyNetworkMutex.Unlock()
	fake.DestroyNetworkStub = nil
	fake.destroyNetworkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DestroyNetworkReturnsOnCall(i int, result1 error) {
	fake.destroyNetworkMutex.Lock()
	defer fake.destroyNetworkMutex.Unlock()
	fake.DestroyNetworkStub = nil
	if fake.destroyNetworkReturnsOnCall == nil {
		fake.destroyNetworkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyNetworkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) GetAllocation(arg1 string) (*network.JobAllocation, error) {
	fake.getAllocationMutex.Lock()
	ret, specificReturn := fake.getAllocationReturnsOnCall[len(fake.getAllocationArgsForCall)]
	fake.getAllocationArgsForCall = append(fake.getAllocationArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAllocationStub
	fakeReturns := fake.getAllocationReturns
	fake.recordInvocation("GetAllocation", []interface{}{arg1})
	fake.getAllocationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetAllocationCallCount() int {
	fake.getAllocationMutex.RLock()
	defer fake.getAllocationMutex.RUnlock()
	return len(fake.getAllocationArgsForCall)
}

func (fake *FakeManager) GetAllocationCalls(stub func(string) (*network.JobAllocation, error)) {
	fake.getAllocationMutex.Lock()
	defer fake.getAllocationMutex.Unlock()
	fake.GetAllocationStub = stub
}

func (fake *FakeManager) GetAllocationArgsForCall(i int) string {
	fake.getAllocationMutex.RLock()
	defer fake.getAllocationMutex.RUnlock()
	argsForCall := fake.getAllocationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) GetAllocationReturns(result1 *network.JobAllocation, result2 error) {
	fake.getAllocationMutex.Lock()
	defer fake.getAllocationMutex.Unlock()
	fake.GetAllocationStub = nil
	fake.getAllocationReturns = struct {
		result1 *network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetAllocationReturnsOnCall(i int, result1 *network.JobAllocation, result2 error) {
	fake.getAllocationMutex.Lock()
	defer fake.getAllocationMutex.Unlock()
	fake.GetAllocationStub = nil
	if fake.getAllocationReturnsOnCall == nil {
		fake.getAllocationReturnsOnCall = make(map[int]struct {
			result1 *network.JobAllocation
			result2 error
		})
	}
	fake.getAllocationReturnsOnCall[i] = struct {
		result1 *network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetBandwidthStats(arg1 string) (*network.BandwidthStats, error) {
	fake.getBandwidthStatsMutex.Lock()
	ret, specificReturn := fake.getBandwidthStatsReturnsOnCall[len(fake.getBandwidthStatsArgsForCall)]
	fake.getBandwidthStatsArgsForCall = append(fake.getBandwidthStatsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBandwidthStatsStub
	fakeReturns := fake.getBandwidthStatsReturns
	fake.recordInvocation("GetBandwidthStats", []interface{}{arg1})
	fake.getBandwidthStatsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetBandwidthStatsCallCount() int {
	fake.getBandwidthStatsMutex.RLock()
	defer fake.getBandwidthStatsMutex.RUnlock()
	return len(fake.getBandwidthStatsArgsForCall)
}

func (fake *FakeManager) GetBandwidthStatsCalls(stub func(string) (*network.BandwidthStats, error)) {
	fake.getBandwidthStatsMutex.Lock()
	defer fake.getBandwidthStatsMutex.Unlock()
	fake.GetBandwidthStatsStub = stub
}

func (fake *FakeManager) GetBandwidthStatsArgsForCall(i int) string {
	fake.getBandwidthStatsMutex.RLock()
	defer fake.getBandwidthStatsMutex.RUnlock()
	argsForCall := fake.getBandwidthStatsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) GetBandwidthStatsReturns(result1 *network.BandwidthStats, result2 error) {
	fake.getBandwidthStatsMutex.Lock()
	defer fake.getBandwidthStatsMutex.Unlock()
	fake.GetBandwidthStatsStub = nil
	fake.getBandwidthStatsReturns = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetBandwidthStatsReturnsOnCall(i int, result1 *network.BandwidthStats, result2 error) {
	fake.getBandwidthStatsMutex.Lock()
	defer fake.getBandwidthStatsMutex.Unlock()
	fake.GetBandwidthStatsStub = nil
	if fake.getBandwidthStatsReturnsOnCall == nil {
		fake.getBandwidthStatsReturnsOnCall = make(map[int]struct {
			result1 *network.BandwidthStats
			result2 error
		})
	}
	fake.getBandwidthStatsReturnsOnCall[i] = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetNetworkInfo(arg1 string) (*network.NetworkInfo, error) {
	fake.getNetworkInfoMutex.Lock()
	ret, specificReturn := fake.getNetworkInfoReturnsOnCall[len(fake.getNetworkInfoArgsForCall)]
	fake.getNetworkInfoArgsForCall = append(fake.getNetworkInfoArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetNetworkInfoStub
	fakeReturns := fake.getNetworkInfoReturns
	fake.recordInvocation("GetNetworkInfo", []interface{}{arg1})
	fake.getNetworkInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetNetworkInfoCallCount() int {
	fake.getNetworkInfoMutex.RLock()
	defer fake.getNetworkInfoMutex.RUnlock()
	return len(fake.getNetworkInfoArgsForCall)
}

func (fake *FakeManager) GetNetworkInfoCalls(stub func(string) (*network.NetworkInfo, error)) {
	fake.getNetworkInfoMutex.Lock()
	defer fake.getNetworkInfoMutex.Unlock()
	fake.GetNetworkInfoStub = stub
}

func (fake *FakeManager) GetNetworkInfoArgsForCall(i int) string {
	fake.getNetworkInfoMutex.RLock()
	defer fake.getNetworkInfoMutex.RUnlock()
	argsForCall := fake.getNetworkInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) GetNetworkInfoReturns(result1 *network.NetworkInfo, result2 error) {
	fake.getNetworkInfoMutex.Lock()
	defer fake.getNetworkInfoMutex.Unlock()
	fake.GetNetworkInfoStub = nil
	fake.getNetworkInfoReturns = struct {
		result1 *network.NetworkInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetNetworkInfoReturnsOnCall(i int, result1 *network.NetworkInfo, result2 error) {
	fake.getNetworkInfoMutex.Lock()
	defer fake.getNetworkInfoMutex.Unlock()
	fake.GetNetworkInfoStub = nil
	if fake.getNetworkInfoReturnsOnCall == nil {
		fake.getNetworkInfoReturnsOnCall = make(map[int]struct {
			result1 *network.NetworkInfo
			result2 error
		})
	}
	fake.getNetworkInfoReturnsOnCall[i] = struct {
		result1 *network.NetworkInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetNetworkStats(arg1 string) (*network.BandwidthStats, error) {
	fake.getNetworkStatsMutex.Lock()
	ret, specificReturn := fake.getNetworkStatsReturnsOnCall[len(fake.getNetworkStatsArgsForCall)]
	fake.getNetworkStatsArgsForCall = append(fake.getNetworkStatsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetNetworkStatsStub
	fakeReturns := fake.getNetworkStatsReturns
	fake.recordInvocation("GetNetworkStats", []interface{}{arg1})
	fake.getNetworkStatsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetNetworkStatsCallCount() int {
	fake.getNetworkStatsMutex.RLock()
	defer fake.getNetworkStatsMutex.RUnlock()
	return len(fake.getNetworkStatsArgsForCall)
}

func (fake *FakeManager) GetNetworkStatsCalls(stub func(string) (*network.BandwidthStats, error)) {
	fake.getNetworkStatsMutex.Lock()
	defer fake.getNetworkStatsMutex.Unlock()
	fake.GetNetworkStatsStub = stub
}

func (fake *FakeManager) GetNetworkStatsArgsForCall(i int) string {
	fake.getNetworkStatsMutex.RLock()
	defer fake.getNetworkStatsMutex.RUnlock()
	argsForCall := fake.getNetworkStatsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) GetNetworkStatsReturns(result1 *network.BandwidthStats, result2 error) {
	fake.getNetworkStatsMutex.Lock()
	defer fake.getNetworkStatsMutex.Unlock()
	fake.GetNetworkStatsStub = nil
	fake.getNetworkStatsReturns = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetNetworkStatsReturnsOnCall(i int, result1 *network.BandwidthStats, result2 error) {
	fake.getNetworkStatsMutex.Lock()
	defer fake.getNetworkStatsMutex.Unlock()
	fake.GetNetworkStatsStub = nil
	if fake.getNetworkStatsReturnsOnCall == nil {
		fake.getNetworkStatsReturnsOnCall = make(map[int]struct {
			result1 *network.BandwidthStats
			result2 error
		})
	}
	fake.getNetworkStatsReturnsOnCall[i] = struct {
		result1 *network.BandwidthStats
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListAllocations(arg1 string) ([]network.JobAllocation, error) {
	fake.listAllocationsMutex.Lock()
	ret, specificReturn := fake.listAllocationsReturnsOnCall[len(fake.listAllocationsArgsForCall)]
	fake.listAllocationsArgsForCall = append(fake.listAllocationsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListAllocationsStub
	fakeReturns := fake.listAllocationsReturns
	fake.recordInvocation("ListAllocations", []interface{}{arg1})
	fake.listAllocationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListAllocationsCallCount() int {
	fake.listAllocationsMutex.RLock()
	defer fake.listAllocationsMutex.RUnlock()
	return len(fake.listAllocationsArgsForCall)
}

func (fake *FakeManager) ListAllocationsCalls(stub func(string) ([]network.JobAllocation, error)) {
	fake.listAllocationsMutex.Lock()
	defer fake.listAllocationsMutex.Unlock()
	fake.ListAllocationsStub = stub
}

func (fake *FakeManager) ListAllocationsArgsForCall(i int) string {
	fake.listAllocationsMutex.RLock()
	defer fake.listAllocationsMutex.RUnlock()
	argsForCall := fake.listAllocationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) ListAllocationsReturns(result1 []network.JobAllocation, result2 error) {
	fake.listAllocationsMutex.Lock()
	defer fake.listAllocationsMutex.Unlock()
	fake.ListAllocationsStub = nil
	fake.listAllocationsReturns = struct {
		result1 []network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListAllocationsReturnsOnCall(i int, result1 []network.JobAllocation, result2 error) {
	fake.listAllocationsMutex.Lock()
	defer fake.listAllocationsMutex.Unlock()
	fake.ListAllocationsStub = nil
	if fake.listAllocationsReturnsOnCall == nil {
		fake.listAllocationsReturnsOnCall = make(map[int]struct {
			result1 []network.JobAllocation
			result2 error
		})
	}
	fake.listAllocationsReturnsOnCall[i] = struct {
		result1 []network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListNetworks() ([]network.NetworkInfo, error) {
	fake.listNetworksMutex.Lock()
	ret, specificReturn := fake.listNetworksReturnsOnCall[len(fake.listNetworksArgsForCall)]
	fake.listNetworksArgsForCall = append(fake.listNetworksArgsForCall, struct {
	}{})
	stub := fake.ListNetworksStub
	fakeReturns := fake.listNetworksReturns
	fake.recordInvocation("ListNetworks", []interface{}{})
	fake.listNetworksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListNetworksCallCount() int {
	fake.listNetworksMutex.RLock()
	defer fake.listNetworksMutex.RUnlock()
	return len(fake.listNetworksArgsForCall)
}

func (fake *FakeManager) ListNetworksCalls(stub func() ([]network.NetworkInfo, error)) {
	fake.listNetworksMutex.Lock()
	defer fake.listNetworksMutex.Unlock()
	fake.ListNetworksStub = stub
}

func (fake *FakeManager) ListNetworksReturns(result1 []network.NetworkInfo, result2 error) {
	fake.listNetworksMutex.Lock()
	defer fake.listNetworksMutex.Unlock()
	fake.ListNetworksStub = nil
	fake.listNetworksReturns = struct {
		result1 []network.NetworkInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListNetworksReturnsOnCall(i int, result1 []network.NetworkInfo, result2 error) {
	fake.listNetworksMutex.Lock()
	defer fake.listNetworksMutex.Unlock()
	fake.ListNetworksStub = nil
	if fake.listNetworksReturnsOnCall == nil {
		fake.listNetworksReturnsOnCall = make(map[int]struct {
			result1 []network.NetworkInfo
			result2 error
		})
	}
	fake.listNetworksReturnsOnCall[i] = struct {
		result1 []network.NetworkInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) NetworkExists(arg1 string) bool {
	fake.networkExistsMutex.Lock()
	ret, specificReturn := fake.networkExistsReturnsOnCall[len(fake.networkExistsArgsForCall)]
	fake.networkExistsArgsForCall = append(fake.networkExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NetworkExistsStub
	fakeReturns := fake.networkExistsReturns
	fake.recordInvocation("NetworkExists", []interface{}{arg1})
	fake.networkExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) NetworkExistsCallCount() int {
	fake.networkExistsMutex.RLock()
	defer fake.networkExistsMutex.RUnlock()
	return len(fake.networkExistsArgsForCall)
}

func (fake *FakeManager) NetworkExistsCalls(stub func(string) bool) {
	fake.networkExistsMutex.Lock()
	defer fake.networkExistsMutex.Unlock()
	fake.NetworkExistsStub = stub
}

func (fake *FakeManager) NetworkExistsArgsForCall(i int) string {
	fake.networkExistsMutex.RLock()
	defer fake.networkExistsMutex.RUnlock()
	argsForCall := fake.networkExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) NetworkExistsReturns(result1 bool) {
	fake.networkExistsMutex.Lock()
	defer fake.networkExistsMutex.Unlock()
	fake.NetworkExistsStub = nil
	fake.networkExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeManager) NetworkExistsReturnsOnCall(i int, result1 bool) {
	fake.networkExistsMutex.Lock()
	defer fake.networkExistsMutex.Unlock()
	fake.NetworkExistsStub = nil
	if fake.networkExistsReturnsOnCall == nil {
		fake.networkExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.networkExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeManager) ReleaseIP(arg1 string) error {
	fake.releaseIPMutex.Lock()
	ret, specificReturn := fake.releaseIPReturnsOnCall[len(fake.releaseIPArgsForCall)]
	fake.releaseIPArgsForCall = append(fake.releaseIPArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReleaseIPStub
	fakeReturns := fake.releaseIPReturns
	fake.recordInvocation("ReleaseIP", []interface{}{arg1})
	fake.releaseIPMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) ReleaseIPCallCount() int {
	fake.releaseIPMutex.RLock()
	defer fake.releaseIPMutex.RUnlock()
	return len(fake.releaseIPArgsForCall)
}

func (fake *FakeManager) ReleaseIPCalls(stub func(string) error) {
	fake.releaseIPMutex.Lock()
	defer fake.releaseIPMutex.Unlock()
	fake.ReleaseIPStub = stub
}

func (fake *FakeManager) ReleaseIPArgsForCall(i int) string {
	fake.releaseIPMutex.RLock()
	defer fake.releaseIPMutex.RUnlock()
	argsForCall := fake.releaseIPArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) ReleaseIPReturns(result1 error) {
	fake.releaseIPMutex.Lock()
	defer fake.releaseIPMutex.Unlock()
	fake.ReleaseIPStub = nil
	fake.releaseIPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ReleaseIPReturnsOnCall(i int, result1 error) {
	fake.releaseIPMutex.Lock()
	defer fake.releaseIPMutex.Unlock()
	fake.ReleaseIPStub = nil
	if fake.releaseIPReturnsOnCall == nil {
		fake.releaseIPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.releaseIPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetBandwidthLimits(arg1 string, arg2 *network.NetworkLimits) error {
	fake.setBandwidthLimitsMutex.Lock()
	ret, specificReturn := fake.setBandwidthLimitsReturnsOnCall[len(fake.setBandwidthLimitsArgsForCall)]
	fake.setBandwidthLimitsArgsForCall = append(fake.setBandwidthLimitsArgsForCall, struct {
		arg1 string
		arg2 *network.NetworkLimits
	}{arg1, arg2})
	stub := fake.SetBandwidthLimitsStub
	fakeReturns := fake.setBandwidthLimitsReturns
	fake.recordInvocation("SetBandwidthLimits", []interface{}{arg1, arg2})
	fake.setBandwidthLimitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) SetBandwidthLimitsCallCount() int {
	fake.setBandwidthLimitsMutex.RLock()
	defer fake.setBandwidthLimitsMutex.RUnlock()
	return len(fake.setBandwidthLimitsArgsForCall)
}

func (fake *FakeManager) SetBandwidthLimitsCalls(stub func(string, *network.NetworkLimits) error) {
	fake.setBandwidthLimitsMutex.Lock()
	defer fake.setBandwidthLimitsMutex.Unlock()
	fake.SetBandwidthLimitsStub = stub
}

func (fake *FakeManager) SetBandwidthLimitsArgsForCall(i int) (string, *network.NetworkLimits) {
	fake.setBandwidthLimitsMutex.RLock()
	defer fake.setBandwidthLimitsMutex.RUnlock()
	argsForCall := fake.setBandwidthLimitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) SetBandwidthLimitsReturns(result1 error) {
	fake.setBandwidthLimitsMutex.Lock()
	defer fake.setBandwidthLimitsMutex.Unlock()
	fake.SetBandwidthLimitsStub = nil
	fake.setBandwidthLimitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetBandwidthLimitsReturnsOnCall(i int, result1 error) {
	fake.setBandwidthLimitsMutex.Lock()
	defer fake.setBandwidthLimitsMutex.Unlock()
	fake.SetBandwidthLimitsStub = nil
	if fake.setBandwidthLimitsReturnsOnCall == nil {
		fake.setBandwidthLimitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBandwidthLimitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetupJobNetworking(arg1 string, arg2 string) (*network.JobAllocation, error) {
	fake.setupJobNetworkingMutex.Lock()
	ret, specificReturn := fake.setupJobNetworkingReturnsOnCall[len(fake.setupJobNetworkingArgsForCall)]
	fake.setupJobNetworkingArgsForCall = append(fake.setupJobNetworkingArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetupJobNetworkingStub
	fakeReturns := fake.setupJobNetworkingReturns
	fake.recordInvocation("SetupJobNetworking", []interface{}{arg1, arg2})
	fake.setupJobNetworkingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) SetupJobNetworkingCallCount() int {
	fake.setupJobNetworkingMutex.RLock()
	defer fake.setupJobNetworkingMutex.RUnlock()
	return len(fake.setupJobNetworkingArgsForCall)
}

func (fake *FakeManager) SetupJobNetworkingCalls(stub func(string, string) (*network.JobAllocation, error)) {
	fake.setupJobNetworkingMutex.Lock()
	defer fake.setupJobNetworkingMutex.Unlock()
	fake.SetupJobNetworkingStub = stub
}

func (fake *FakeManager) SetupJobNetworkingArgsForCall(i int) (string, string) {
	fake.setupJobNetworkingMutex.RLock()
	defer fake.setupJobNetworkingMutex.RUnlock()
	argsForCall := fake.setupJobNetworkingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) SetupJobNetworkingReturns(result1 *network.JobAllocation, result2 error) {
	fake.setupJobNetworkingMutex.Lock()
	defer fake.setupJobNetworkingMutex.Unlock()
	fake.SetupJobNetworkingStub = nil
	fake.setupJobNetworkingReturns = struct {
		result1 *network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) SetupJobNetworkingReturnsOnCall(i int, result1 *network.JobAllocation, result2 error) {
	fake.setupJobNetworkingMutex.Lock()
	defer fake.setupJobNetworkingMutex.Unlock()
	fake.SetupJobNetworkingStub = nil
	if fake.setupJobNetworkingReturnsOnCall == nil {
		fake.setupJobNetworkingReturnsOnCall = make(map[int]struct {
			result1 *network.JobAllocation
			result2 error
		})
	}
	fake.setupJobNetworkingReturnsOnCall[i] = struct {
		result1 *network.JobAllocation
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) StartMonitoring(arg1 context.Context) error {
	fake.startMonitoringMutex.Lock()
	ret, specificReturn := fake.startMonitoringReturnsOnCall[len(fake.startMonitoringArgsForCall)]
	fake.startMonitoringArgsForCall = append(fake.startMonitoringArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StartMonitoringStub
	fakeReturns := fake.startMonitoringReturns
	fake.recordInvocation("StartMonitoring", []interface{}{arg1})
	fake.startMonitoringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) StartMonitoringCallCount() int {
	fake.startMonitoringMutex.RLock()
	defer fake.startMonitoringMutex.RUnlock()
	return len(fake.startMonitoringArgsForCall)
}

func (fake *FakeManager) StartMonitoringCalls(stub func(context.Context) error) {
	fake.startMonitoringMutex.Lock()
	defer fake.startMonitoringMutex.Unlock()
	fake.StartMonitoringStub = stub
}

func (fake *FakeManager) StartMonitoringArgsForCall(i int) context.Context {
	fake.startMonitoringMutex.RLock()
	defer fake.startMonitoringMutex.RUnlock()
	argsForCall := fake.startMonitoringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) StartMonitoringReturns(result1 error) {
	fake.startMonitoringMutex.Lock()
	defer fake.startMonitoringMutex.Unlock()
	fake.StartMonitoringStub = nil
	fake.startMonitoringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) StartMonitoringReturnsOnCall(i int, result1 error) {
	fake.startMonitoringMutex.Lock()
	defer fake.startMonitoringMutex.Unlock()
	fake.StartMonitoringStub = nil
	if fake.startMonitoringReturnsOnCall == nil {
		fake.startMonitoringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startMonitoringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) StopMonitoring() error {
	fake.stopMonitoringMutex.Lock()
	ret, specificReturn := fake.stopMonitoringReturnsOnCall[len(fake.stopMonitoringArgsForCall)]
	fake.stopMonitoringArgsForCall = append(fake.stopMonitoringArgsForCall, struct {
	}{})
	stub := fake.StopMonitoringStub
	fakeReturns := fake.stopMonitoringReturns
	fake.recordInvocation("StopMonitoring", []interface{}{})
	fake.stopMonitoringMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) StopMonitoringCallCount() int {
	fake.stopMonitoringMutex.RLock()
	defer fake.stopMonitoringMutex.RUnlock()
	return len(fake.stopMonitoringArgsForCall)
}

func (fake *FakeManager) StopMonitoringCalls(stub func() error) {
	fake.stopMonitoringMutex.Lock()
	defer fake.stopMonitoringMutex.Unlock()
	fake.StopMonitoringStub = stub
}

func (fake *FakeManager) StopMonitoringReturns(result1 error) {
	fake.stopMonitoringMutex.Lock()
	defer fake.stopMonitoringMutex.Unlock()
	fake.StopMonitoringStub = nil
	fake.stopMonitoringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) StopMonitoringReturnsOnCall(i int, result1 error) {
	fake.stopMonitoringMutex.Lock()
	defer fake.stopMonitoringMutex.Unlock()
	fake.StopMonitoringStub = nil
	if fake.stopMonitoringReturnsOnCall == nil {
		fake.stopMonitoringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopMonitoringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ValidateNetworkConfig(arg1 *network.NetworkConfig) error {
	fake.validateNetworkConfigMutex.Lock()
	ret, specificReturn := fake.validateNetworkConfigReturnsOnCall[len(fake.validateNetworkConfigArgsForCall)]
	fake.validateNetworkConfigArgsForCall = append(fake.validateNetworkConfigArgsForCall, struct {
		arg1 *network.NetworkConfig
	}{arg1})
	stub := fake.ValidateNetworkConfigStub
	fakeReturns := fake.validateNetworkConfigReturns
	fake.recordInvocation("ValidateNetworkConfig", []interface{}{arg1})
	fake.validateNetworkConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) ValidateNetworkConfigCallCount() int {
	fake.validateNetworkConfigMutex.RLock()
	defer fake.validateNetworkConfigMutex.RUnlock()
	return len(fake.validateNetworkConfigArgsForCall)
}

func (fake *FakeManager) ValidateNetworkConfigCalls(stub func(*network.NetworkConfig) error) {
	fake.validateNetworkConfigMutex.Lock()
	defer fake.validateNetworkConfigMutex.Unlock()
	fake.ValidateNetworkConfigStub = stub
}

func (fake *FakeManager) ValidateNetworkConfigArgsForCall(i int) *network.NetworkConfig {
	fake.validateNetworkConfigMutex.RLock()
	defer fake.validateNetworkConfigMutex.RUnlock()
	argsForCall := fake.validateNetworkConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) ValidateNetworkConfigReturns(result1 error) {
	fake.validateNetworkConfigMutex.Lock()
	defer fake.validateNetworkConfigMutex.Unlock()
	fake.ValidateNetworkConfigStub = nil
	fake.validateNetworkConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ValidateNetworkConfigReturnsOnCall(i int, result1 error) {
	fake.validateNetworkConfigMutex.Lock()
	defer fake.validateNetworkConfigMutex.Unlock()
	fake.ValidateNetworkConfigStub = nil
	if fake.validateNetworkConfigReturnsOnCall == nil {
		fake.validateNetworkConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateNetworkConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ network.Manager = new(FakeManager)
