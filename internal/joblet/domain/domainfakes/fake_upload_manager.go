// Code generated by counterfeiter. DO NOT EDIT.
package domainfakes

import (
	"sync"

	"github.com/ehsaniara/joblet/internal/joblet/domain"
)

type FakeUploadManager struct {
	CleanupTransportStub        func(domain.UploadTransport) error
	cleanupTransportMutex       sync.RWMutex
	cleanupTransportArgsForCall []struct {
		arg1 domain.UploadTransport
	}
	cleanupTransportReturns struct {
		result1 error
	}
	cleanupTransportReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTransportStub        func(string) (domain.UploadTransport, error)
	createTransportMutex       sync.RWMutex
	createTransportArgsForCall []struct {
		arg1 string
	}
	createTransportReturns struct {
		result1 domain.UploadTransport
		result2 error
	}
	createTransportReturnsOnCall map[int]struct {
		result1 domain.UploadTransport
		result2 error
	}
	PrepareUploadSessionStub        func(string, []domain.FileUpload, int32) (*domain.UploadSession, error)
	prepareUploadSessionMutex       sync.RWMutex
	prepareUploadSessionArgsForCall []struct {
		arg1 string
		arg2 []domain.FileUpload
		arg3 int32
	}
	prepareUploadSessionReturns struct {
		result1 *domain.UploadSession
		result2 error
	}
	prepareUploadSessionReturnsOnCall map[int]struct {
		result1 *domain.UploadSession
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUploadManager) CleanupTransport(arg1 domain.UploadTransport) error {
	fake.cleanupTransportMutex.Lock()
	ret, specificReturn := fake.cleanupTransportReturnsOnCall[len(fake.cleanupTransportArgsForCall)]
	fake.cleanupTransportArgsForCall = append(fake.cleanupTransportArgsForCall, struct {
		arg1 domain.UploadTransport
	}{arg1})
	stub := fake.CleanupTransportStub
	fakeReturns := fake.cleanupTransportReturns
	fake.recordInvocation("CleanupTransport", []interface{}{arg1})
	fake.cleanupTransportMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUploadManager) CleanupTransportCallCount() int {
	fake.cleanupTransportMutex.RLock()
	defer fake.cleanupTransportMutex.RUnlock()
	return len(fake.cleanupTransportArgsForCall)
}

func (fake *FakeUploadManager) CleanupTransportCalls(stub func(domain.UploadTransport) error) {
	fake.cleanupTransportMutex.Lock()
	defer fake.cleanupTransportMutex.Unlock()
	fake.CleanupTransportStub = stub
}

func (fake *FakeUploadManager) CleanupTransportArgsForCall(i int) domain.UploadTransport {
	fake.cleanupTransportMutex.RLock()
	defer fake.cleanupTransportMutex.RUnlock()
	argsForCall := fake.cleanupTransportArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUploadManager) CleanupTransportReturns(result1 error) {
	fake.cleanupTransportMutex.Lock()
	defer fake.cleanupTransportMutex.Unlock()
	fake.CleanupTransportStub = nil
	fake.cleanupTransportReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUploadManager) CleanupTransportReturnsOnCall(i int, result1 error) {
	fake.cleanupTransportMutex.Lock()
	defer fake.cleanupTransportMutex.Unlock()
	fake.CleanupTransportStub = nil
	if fake.cleanupTransportReturnsOnCall == nil {
		fake.cleanupTransportReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupTransportReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUploadManager) CreateTransport(arg1 string) (domain.UploadTransport, error) {
	fake.createTransportMutex.Lock()
	ret, specificReturn := fake.createTransportReturnsOnCall[len(fake.createTransportArgsForCall)]
	fake.createTransportArgsForCall = append(fake.createTransportArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateTransportStub
	fakeReturns := fake.createTransportReturns
	fake.recordInvocation("CreateTransport", []interface{}{arg1})
	fake.createTransportMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUploadManager) CreateTransportCallCount() int {
	fake.createTransportMutex.RLock()
	defer fake.createTransportMutex.RUnlock()
	return len(fake.createTransportArgsForCall)
}

func (fake *FakeUploadManager) CreateTransportCalls(stub func(string) (domain.UploadTransport, error)) {
	fake.createTransportMutex.Lock()
	defer fake.createTransportMutex.Unlock()
	fake.CreateTransportStub = stub
}

func (fake *FakeUploadManager) CreateTransportArgsForCall(i int) string {
	fake.createTransportMutex.RLock()
	defer fake.createTransportMutex.RUnlock()
	argsForCall := fake.createTransportArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUploadManager) CreateTransportReturns(result1 domain.UploadTransport, result2 error) {
	fake.createTransportMutex.Lock()
	defer fake.createTransportMutex.Unlock()
	fake.CreateTransportStub = nil
	fake.createTransportReturns = struct {
		result1 domain.UploadTransport
		result2 error
	}{result1, result2}
}

func (fake *FakeUploadManager) CreateTransportReturnsOnCall(i int, result1 domain.UploadTransport, result2 error) {
	fake.createTransportMutex.Lock()
	defer fake.createTransportMutex.Unlock()
	fake.CreateTransportStub = nil
	if fake.createTransportReturnsOnCall == nil {
		fake.createTransportReturnsOnCall = make(map[int]struct {
			result1 domain.UploadTransport
			result2 error
		})
	}
	fake.createTransportReturnsOnCall[i] = struct {
		result1 domain.UploadTransport
		result2 error
	}{result1, result2}
}

func (fake *FakeUploadManager) PrepareUploadSession(arg1 string, arg2 []domain.FileUpload, arg3 int32) (*domain.UploadSession, error) {
	var arg2Copy []domain.FileUpload
	if arg2 != nil {
		arg2Copy = make([]domain.FileUpload, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.prepareUploadSessionMutex.Lock()
	ret, specificReturn := fake.prepareUploadSessionReturnsOnCall[len(fake.prepareUploadSessionArgsForCall)]
	fake.prepareUploadSessionArgsForCall = append(fake.prepareUploadSessionArgsForCall, struct {
		arg1 string
		arg2 []domain.FileUpload
		arg3 int32
	}{arg1, arg2Copy, arg3})
	stub := fake.PrepareUploadSessionStub
	fakeReturns := fake.prepareUploadSessionReturns
	fake.recordInvocation("PrepareUploadSession", []interface{}{arg1, arg2Copy, arg3})
	fake.prepareUploadSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUploadManager) PrepareUploadSessionCallCount() int {
	fake.prepareUploadSessionMutex.RLock()
	defer fake.prepareUploadSessionMutex.RUnlock()
	return len(fake.prepareUploadSessionArgsForCall)
}

func (fake *FakeUploadManager) PrepareUploadSessionCalls(stub func(string, []domain.FileUpload, int32) (*domain.UploadSession, error)) {
	fake.prepareUploadSessionMutex.Lock()
	defer fake.prepareUploadSessionMutex.Unlock()
	fake.PrepareUploadSessionStub = stub
}

func (fake *FakeUploadManager) PrepareUploadSessionArgsForCall(i int) (string, []domain.FileUpload, int32) {
	fake.prepareUploadSessionMutex.RLock()
	defer fake.prepareUploadSessionMutex.RUnlock()
	argsForCall := fake.prepareUploadSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUploadManager) PrepareUploadSessionReturns(result1 *domain.UploadSession, result2 error) {
	fake.prepareUploadSessionMutex.Lock()
	defer fake.prepareUploadSessionMutex.Unlock()
	fake.PrepareUploadSessionStub = nil
	fake.prepareUploadSessionReturns = struct {
		result1 *domain.UploadSession
		result2 error
	}{result1, result2}
}

func (fake *FakeUploadManager) PrepareUploadSessionReturnsOnCall(i int, result1 *domain.UploadSession, result2 error) {
	fake.prepareUploadSessionMutex.Lock()
	defer fake.prepareUploadSessionMutex.Unlock()
	fake.PrepareUploadSessionStub = nil
	if fake.prepareUploadSessionReturnsOnCall == nil {
		fake.prepareUploadSessionReturnsOnCall = make(map[int]struct {
			result1 *domain.UploadSession
			result2 error
		})
	}
	fake.prepareUploadSessionReturnsOnCall[i] = struct {
		result1 *domain.UploadSession
		result2 error
	}{result1, result2}
}

func (fake *FakeUploadManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUploadManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.UploadManager = new(FakeUploadManager)
