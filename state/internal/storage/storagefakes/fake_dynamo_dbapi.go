// Code generated by counterfeiter. DO NOT EDIT.
package storagefakes

import (
	"context"
	"sync"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/ehsaniara/joblet/state/internal/storage"
)

type FakeDynamoDBAPI struct {
	BatchWriteItemStub        func(context.Context, *dynamodb.BatchWriteItemInput, ...func(*dynamodb.Options)) (*dynamodb.BatchWriteItemOutput, error)
	batchWriteItemMutex       sync.RWMutex
	batchWriteItemArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodb.BatchWriteItemInput
		arg3 []func(*dynamodb.Options)
	}
	batchWriteItemReturns struct {
		result1 *dynamodb.BatchWriteItemOutput
		result2 error
	}
	batchWriteItemReturnsOnCall map[int]struct {
		result1 *dynamodb.BatchWriteItemOutput
		result2 error
	}
	DeleteItemStub        func(context.Context, *dynamodb.DeleteItemInput, ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)
	deleteItemMutex       sync.RWMutex
	deleteItemArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodb.DeleteItemInput
		arg3 []func(*dynamodb.Options)
	}
	deleteItemReturns struct {
		result1 *dynamodb.DeleteItemOutput
		result2 error
	}
	deleteItemReturnsOnCall map[int]struct {
		result1 *dynamodb.DeleteItemOutput
		result2 error
	}
	DescribeTableStub        func(context.Context, *dynamodb.DescribeTableInput, ...func(*dynamodb.Options)) (*dynamodb.DescribeTableOutput, error)
	describeTableMutex       sync.RWMutex
	describeTableArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodb.DescribeTableInput
		arg3 []func(*dynamodb.Options)
	}
	describeTableReturns struct {
		result1 *dynamodb.DescribeTableOutput
		result2 error
	}
	describeTableReturnsOnCall map[int]struct {
		result1 *dynamodb.DescribeTableOutput
		result2 error
	}
	GetItemStub        func(context.Context, *dynamodb.GetItemInput, ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
	getItemMutex       sync.RWMutex
	getItemArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodb.GetItemInput
		arg3 []func(*dynamodb.Options)
	}
	getItemReturns struct {
		result1 *dynamodb.GetItemOutput
		result2 error
	}
	getItemReturnsOnCall map[int]struct {
		result1 *dynamodb.GetItemOutput
		result2 error
	}
	PutItemStub        func(context.Context, *dynamodb.PutItemInput, ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
	putItemMutex       sync.RWMutex
	putItemArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodb.PutItemInput
		arg3 []func(*dynamodb.Options)
	}
	putItemReturns struct {
		result1 *dynamodb.PutItemOutput
		result2 error
	}
	putItemReturnsOnCall map[int]struct {
		result1 *dynamodb.PutItemOutput
		result2 error
	}
	ScanStub        func(context.Context, *dynamodb.ScanInput, ...func(*dynamodb.Options)) (*dynamodb.ScanOutput, error)
	scanMutex       sync.RWMutex
	scanArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodb.ScanInput
		arg3 []func(*dynamodb.Options)
	}
	scanReturns struct {
		result1 *dynamodb.ScanOutput
		result2 error
	}
	scanReturnsOnCall map[int]struct {
		result1 *dynamodb.ScanOutput
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDynamoDBAPI) BatchWriteItem(arg1 context.Context, arg2 *dynamodb.BatchWriteItemInput, arg3 ...func(*dynamodb.Options)) (*dynamodb.BatchWriteItemOutput, error) {
	fake.batchWriteItemMutex.Lock()
	ret, specificReturn := fake.batchWriteItemReturnsOnCall[len(fake.batchWriteItemArgsForCall)]
	fake.batchWriteItemArgsForCall = append(fake.batchWriteItemArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodb.BatchWriteItemInput
		arg3 []func(*dynamodb.Options)
	}{arg1, arg2, arg3})
	stub := fake.BatchWriteItemStub
	fakeReturns := fake.batchWriteItemReturns
	fake.recordInvocation("BatchWriteItem", []interface{}{arg1, arg2, arg3})
	fake.batchWriteItemMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDBAPI) BatchWriteItemCallCount() int {
	fake.batchWriteItemMutex.RLock()
	defer fake.batchWriteItemMutex.RUnlock()
	return len(fake.batchWriteItemArgsForCall)
}

func (fake *FakeDynamoDBAPI) BatchWriteItemCalls(stub func(context.Context, *dynamodb.BatchWriteItemInput, ...func(*dynamodb.Options)) (*dynamodb.BatchWriteItemOutput, error)) {
	fake.batchWriteItemMutex.Lock()
	defer fake.batchWriteItemMutex.Unlock()
	fake.BatchWriteItemStub = stub
}

func (fake *FakeDynamoDBAPI) BatchWriteItemArgsForCall(i int) (context.Context, *dynamodb.BatchWriteItemInput, []func(*dynamodb.Options)) {
	fake.batchWriteItemMutex.RLock()
	defer fake.batchWriteItemMutex.RUnlock()
	argsForCall := fake.batchWriteItemArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDBAPI) BatchWriteItemReturns(result1 *dynamodb.BatchWriteItemOutput, result2 error) {
	fake.batchWriteItemMutex.Lock()
	defer fake.batchWriteItemMutex.Unlock()
	fake.BatchWriteItemStub = nil
	fake.batchWriteItemReturns = struct {
		result1 *dynamodb.BatchWriteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) BatchWriteItemReturnsOnCall(i int, result1 *dynamodb.BatchWriteItemOutput, result2 error) {
	fake.batchWriteItemMutex.Lock()
	defer fake.batchWriteItemMutex.Unlock()
	fake.BatchWriteItemStub = nil
	if fake.batchWriteItemReturnsOnCall == nil {
		fake.batchWriteItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodb.BatchWriteItemOutput
			result2 error
		})
	}
	fake.batchWriteItemReturnsOnCall[i] = struct {
		result1 *dynamodb.BatchWriteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) DeleteItem(arg1 context.Context, arg2 *dynamodb.DeleteItemInput, arg3 ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error) {
	fake.deleteItemMutex.Lock()
	ret, specificReturn := fake.deleteItemReturnsOnCall[len(fake.deleteItemArgsForCall)]
	fake.deleteItemArgsForCall = append(fake.deleteItemArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodb.DeleteItemInput
		arg3 []func(*dynamodb.Options)
	}{arg1, arg2, arg3})
	stub := fake.DeleteItemStub
	fakeReturns := fake.deleteItemReturns
	fake.recordInvocation("DeleteItem", []interface{}{arg1, arg2, arg3})
	fake.deleteItemMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDBAPI) DeleteItemCallCount() int {
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	return len(fake.deleteItemArgsForCall)
}

func (fake *FakeDynamoDBAPI) DeleteItemCalls(stub func(context.Context, *dynamodb.DeleteItemInput, ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)) {
	fake.deleteItemMutex.Lock()
	defer fake.deleteItemMutex.Unlock()
	fake.DeleteItemStub = stub
}

func (fake *FakeDynamoDBAPI) DeleteItemArgsForCall(i int) (context.Context, *dynamodb.DeleteItemInput, []func(*dynamodb.Options)) {
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	argsForCall := fake.deleteItemArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDBAPI) DeleteItemReturns(result1 *dynamodb.DeleteItemOutput, result2 error) {
	fake.deleteItemMutex.Lock()
	defer fake.deleteItemMutex.Unlock()
	fake.DeleteItemStub = nil
	fake.deleteItemReturns = struct {
		result1 *dynamodb.DeleteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) DeleteItemReturnsOnCall(i int, result1 *dynamodb.DeleteItemOutput, result2 error) {
	fake.deleteItemMutex.Lock()
	defer fake.deleteItemMutex.Unlock()
	fake.DeleteItemStub = nil
	if fake.deleteItemReturnsOnCall == nil {
		fake.deleteItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodb.DeleteItemOutput
			result2 error
		})
	}
	fake.deleteItemReturnsOnCall[i] = struct {
		result1 *dynamodb.DeleteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) DescribeTable(arg1 context.Context, arg2 *dynamodb.DescribeTableInput, arg3 ...func(*dynamodb.Options)) (*dynamodb.DescribeTableOutput, error) {
	fake.describeTableMutex.Lock()
	ret, specificReturn := fake.describeTableReturnsOnCall[len(fake.describeTableArgsForCall)]
	fake.describeTableArgsForCall = append(fake.describeTableArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodb.DescribeTableInput
		arg3 []func(*dynamodb.Options)
	}{arg1, arg2, arg3})
	stub := fake.DescribeTableStub
	fakeReturns := fake.describeTableReturns
	fake.recordInvocation("DescribeTable", []interface{}{arg1, arg2, arg3})
	fake.describeTableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDBAPI) DescribeTableCallCount() int {
	fake.describeTableMutex.RLock()
	defer fake.describeTableMutex.RUnlock()
	return len(fake.describeTableArgsForCall)
}

func (fake *FakeDynamoDBAPI) DescribeTableCalls(stub func(context.Context, *dynamodb.DescribeTableInput, ...func(*dynamodb.Options)) (*dynamodb.DescribeTableOutput, error)) {
	fake.describeTableMutex.Lock()
	defer fake.describeTableMutex.Unlock()
	fake.DescribeTableStub = stub
}

func (fake *FakeDynamoDBAPI) DescribeTableArgsForCall(i int) (context.Context, *dynamodb.DescribeTableInput, []func(*dynamodb.Options)) {
	fake.describeTableMutex.RLock()
	defer fake.describeTableMutex.RUnlock()
	argsForCall := fake.describeTableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDBAPI) DescribeTableReturns(result1 *dynamodb.DescribeTableOutput, result2 error) {
	fake.describeTableMutex.Lock()
	defer fake.describeTableMutex.Unlock()
	fake.DescribeTableStub = nil
	fake.describeTableReturns = struct {
		result1 *dynamodb.DescribeTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) DescribeTableReturnsOnCall(i int, result1 *dynamodb.DescribeTableOutput, result2 error) {
	fake.describeTableMutex.Lock()
	defer fake.describeTableMutex.Unlock()
	fake.DescribeTableStub = nil
	if fake.describeTableReturnsOnCall == nil {
		fake.describeTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodb.DescribeTableOutput
			result2 error
		})
	}
	fake.describeTableReturnsOnCall[i] = struct {
		result1 *dynamodb.DescribeTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) GetItem(arg1 context.Context, arg2 *dynamodb.GetItemInput, arg3 ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {
	fake.getItemMutex.Lock()
	ret, specificReturn := fake.getItemReturnsOnCall[len(fake.getItemArgsForCall)]
	fake.getItemArgsForCall = append(fake.getItemArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodb.GetItemInput
		arg3 []func(*dynamodb.Options)
	}{arg1, arg2, arg3})
	stub := fake.GetItemStub
	fakeReturns := fake.getItemReturns
	fake.recordInvocation("GetItem", []interface{}{arg1, arg2, arg3})
	fake.getItemMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDBAPI) GetItemCallCount() int {
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	return len(fake.getItemArgsForCall)
}

func (fake *FakeDynamoDBAPI) GetItemCalls(stub func(context.Context, *dynamodb.GetItemInput, ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)) {
	fake.getItemMutex.Lock()
	defer fake.getItemMutex.Unlock()
	fake.GetItemStub = stub
}

func (fake *FakeDynamoDBAPI) GetItemArgsForCall(i int) (context.Context, *dynamodb.GetItemInput, []func(*dynamodb.Options)) {
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	argsForCall := fake.getItemArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDBAPI) GetItemReturns(result1 *dynamodb.GetItemOutput, result2 error) {
	fake.getItemMutex.Lock()
	defer fake.getItemMutex.Unlock()
	fake.GetItemStub = nil
	fake.getItemReturns = struct {
		result1 *dynamodb.GetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) GetItemReturnsOnCall(i int, result1 *dynamodb.GetItemOutput, result2 error) {
	fake.getItemMutex.Lock()
	defer fake.getItemMutex.Unlock()
	fake.GetItemStub = nil
	if fake.getItemReturnsOnCall == nil {
		fake.getItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodb.GetItemOutput
			result2 error
		})
	}
	fake.getItemReturnsOnCall[i] = struct {
		result1 *dynamodb.GetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) PutItem(arg1 context.Context, arg2 *dynamodb.PutItemInput, arg3 ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
	fake.putItemMutex.Lock()
	ret, specificReturn := fake.putItemReturnsOnCall[len(fake.putItemArgsForCall)]
	fake.putItemArgsForCall = append(fake.putItemArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodb.PutItemInput
		arg3 []func(*dynamodb.Options)
	}{arg1, arg2, arg3})
	stub := fake.PutItemStub
	fakeReturns := fake.putItemReturns
	fake.recordInvocation("PutItem", []interface{}{arg1, arg2, arg3})
	fake.putItemMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDBAPI) PutItemCallCount() int {
	fake.putItemMutex.RLock()
	defer fake.putItemMutex.RUnlock()
	return len(fake.putItemArgsForCall)
}

func (fake *FakeDynamoDBAPI) PutItemCalls(stub func(context.Context, *dynamodb.PutItemInput, ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)) {
	fake.putItemMutex.Lock()
	defer fake.putItemMutex.Unlock()
	fake.PutItemStub = stub
}

func (fake *FakeDynamoDBAPI) PutItemArgsForCall(i int) (context.Context, *dynamodb.PutItemInput, []func(*dynamodb.Options)) {
	fake.putItemMutex.RLock()
	defer fake.putItemMutex.RUnlock()
	argsForCall := fake.putItemArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDBAPI) PutItemReturns(result1 *dynamodb.PutItemOutput, result2 error) {
	fake.putItemMutex.Lock()
	defer fake.putItemMutex.Unlock()
	fake.PutItemStub = nil
	fake.putItemReturns = struct {
		result1 *dynamodb.PutItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) PutItemReturnsOnCall(i int, result1 *dynamodb.PutItemOutput, result2 error) {
	fake.putItemMutex.Lock()
	defer fake.putItemMutex.Unlock()
	fake.PutItemStub = nil
	if fake.putItemReturnsOnCall == nil {
		fake.putItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodb.PutItemOutput
			result2 error
		})
	}
	fake.putItemReturnsOnCall[i] = struct {
		result1 *dynamodb.PutItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) Scan(arg1 context.Context, arg2 *dynamodb.ScanInput, arg3 ...func(*dynamodb.Options)) (*dynamodb.ScanOutput, error) {
	fake.scanMutex.Lock()
	ret, specificReturn := fake.scanReturnsOnCall[len(fake.scanArgsForCall)]
	fake.scanArgsForCall = append(fake.scanArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodb.ScanInput
		arg3 []func(*dynamodb.Options)
	}{arg1, arg2, arg3})
	stub := fake.ScanStub
	fakeReturns := fake.scanReturns
	fake.recordInvocation("Scan", []interface{}{arg1, arg2, arg3})
	fake.scanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDBAPI) ScanCallCount() int {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	return len(fake.scanArgsForCall)
}

func (fake *FakeDynamoDBAPI) ScanCalls(stub func(context.Context, *dynamodb.ScanInput, ...func(*dynamodb.Options)) (*dynamodb.ScanOutput, error)) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = stub
}

func (fake *FakeDynamoDBAPI) ScanArgsForCall(i int) (context.Context, *dynamodb.ScanInput, []func(*dynamodb.Options)) {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	argsForCall := fake.scanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDBAPI) ScanReturns(result1 *dynamodb.ScanOutput, result2 error) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = nil
	fake.scanReturns = struct {
		result1 *dynamodb.ScanOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) ScanReturnsOnCall(i int, result1 *dynamodb.ScanOutput, result2 error) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = nil
	if fake.scanReturnsOnCall == nil {
		fake.scanReturnsOnCall = make(map[int]struct {
			result1 *dynamodb.ScanOutput
			result2 error
		})
	}
	fake.scanReturnsOnCall[i] = struct {
		result1 *dynamodb.ScanOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDBAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDynamoDBAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ storage.DynamoDBAPI = new(FakeDynamoDBAPI)
